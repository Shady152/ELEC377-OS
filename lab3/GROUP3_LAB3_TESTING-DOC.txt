T­eam Members:
Jose Ramon Gonzalez
Group: 3
Lab 3

TESTING:

There were a total of 6 tests that were performed. The criteria for all test is as follows: 

1. All the data from the producer(s) is read and output by the consumer(s)
2. None of the data is duplicated
3. The data appears in the output in the same order that it was read by the producers

For the testing many to many, one to many, and one to one were all tested and the terminal outputs were saved for each test. Two bash scripts were also written, one to concatenate the output files and the other to sort the concatenated file and search for duplicates. Two were made since there are two test cases were we have one consumer and thus do not need to merge output files but for one of those two cases we do need to sort the output.

The bash script sort_check_dups_out sorts the given file and checks for duplicates; this file only takes one input parameter. The merge_check_files script takes between 2 and 5 input parameters and merges them into a new file titled merged_out{test_number}. Before saving the merged file the script then calls sort_check_dups_out to sort and check the merged data for duplicates. Additionally, the merge_check_files script checks if the file it’s creating already exists and if it does it exits with an error; the script also checks if the files that are input as parameters exist and if they do not then it will not include them in the merge; finally, the script checks that the correct number of parameters are input into it. The sort_check_dups_out script also checks that the correct number of inputs are given and if the file it is given exists.

The data for each test was generated by making copies of the provided data and renaming it to match the test number; note the number of producers in a test dictated how many copies were made so if there were 2 producers then t10.dat and t11.dat were copied to tx0.dat and tx1.dat for example.

After the test data was generated then the following tests were performed:

Test 1: ./main 1 3 2

Many producers (3) to many consumers (2) where there are more producers than consumers.

Test 2: ./main 2 2 3

Many producers (2) to many consumers (3) where there are less producers than consumers.

Test 3: ./main 3 3 3

Many producers (3) to many consumers (3) where there are the same number of producers to consumers.

Test 4: ./main 4 1 1

One producer to one consumer.

Test 5: ./main 5 3 1

Many producers (3) to one consumer.

Test 6: ./main 6 1 3

One producer to many consumers (3).

For all tests the output generated to the terminal was saved to a file names testx_terminal_output.txt, which is how we verified that condition 3 was met for all tests. By looking at the read and writes from each producer and each consumer we were able to verify that the data appeared in the consumer output in the same order that it was read by the producers; this was done by looking at the outxx.dat files for each test and each consumer and comparing to the terminal output. After the ./main x x x command was run we got file(s) titled outxx.dat. For tests 1,2,3,6 we had multiple files since we had multiple consumers so we ran the merge_check_files script; while for tests 4 and 5 we ran the sort_check_dups_out script since we had one consumer thus one outxx.dat file. Both of these command print a warning if there are duplicates and what the duplicates are, which was how we verified that condition 2 was met. Now for tests 1,2,3,5 we made a sorted file with all the values of all the producer files titled tx_total.dat and we compared this to the sorted merged output merged_outx for filed 1,2,3 and out50_sorted.dat since test 5 only had one consumer so it wasn’t necessary to merge the data. For test 4 we simply compared t40.dat to out40.dat; and for test 6 we compared t60.dat to merged_out6 since test 4 and 6 only had one producer. This was how we verified that condition 1 was met. The input and output files along with the terminal output and merged/sorted outputs for each test can all be found in the directories for each test titled testx/. All conditions were met for all test cases, thus we can conclude that the code worked as expected.
